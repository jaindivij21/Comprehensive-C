According to me this was definately not a medium problem, rather more of a medium-hard one and requires good understanding of 
mainly recursion and further Dynamic Programming to make it efficient. I had to go through some discussion posts to finally come up 
with this answer, hope you find it useful.

How it works?

1) Base cases
    * If n is 0 or a multiple of 2 : in both cases, a full binary tree isn't possible, so we return empty vector.
    * If n is 1 we return a vector with just one node with val = 0.
    * This base case comes from Memorization (DP) : if we have seen/stored the vector of Full Binary Trees/roots already for some n, 
      just return that. I used a map for memorization.
2) Main Part/Recursive Part
    * Firstly get all the possible node combinations that exist in the left and right subtree. For example: for n = 7: the combinations 
      can be (1,5);(3,3);(5,1). Use recursion to get all the possible combinations.
    * Now for all the combinations, find all the possible permutations using nested loops, and push them into ans vector. Finally return 
      the vector, but remember to memorize it.
